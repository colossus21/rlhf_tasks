<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Row a Boat - Enhanced</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background: #e0f3ff;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            background: #87CEEB; /* Light blue for water effect */
            border: 2px solid #0077be;
        }
        #gameOverScreen {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            text-align: center;
            border-radius: 10px;
        }
        #restartButton {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas" width="400" height="600"></canvas>
<div id="gameOverScreen">
    <h2>Game Over</h2>
    <p>Your Score: <span id="finalScore"></span></p>
    <button id="restartButton">Restart Game</button>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const finalScore = document.getElementById('finalScore');
    const restartButton = document.getElementById('restartButton');

    // Load images
    const boatImage = new Image();
    boatImage.src = 'boat.png'; // Ensure this path is correct

    const boat = {
        x: canvas.width / 2 - 20, // Adjusted for image width
        y: canvas.height - 70,
        width: 40,
        height: 60
    };

    let obstacles = [];
    let score = 0;
    let gameOver = false;

    // Obstacle types
    const obstacleTypes = [
        {type: 'rock', color: 'grey', width: 20, height: 20},
        {type: 'plank', color: 'brown', width: 40, height: 10},
        {type: 'iceberg', color: 'lightblue', width: 60, height: 30}
    ];

    function drawBoat() {
        ctx.drawImage(boatImage, boat.x, boat.y, boat.width, boat.height);
    }

    function drawObstacles() {
        obstacles.forEach(obstacle => {
            ctx.fillStyle = obstacle.color;
            ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
        });
    }

    function createObstacle() {
        const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
        obstacles.push({
            ...type,
            x: Math.random() * (canvas.width - type.width),
            y: -type.height,
            speed: 2 + Math.random() * 2
        });
    }

    function updateGame() {
        if (gameOver) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBoat();
        drawObstacles();
        updateObstacles();
        drawScore();

        if (checkCollision()) {
            gameOver = true;
            gameOverScreen.style.display = 'block';
            finalScore.textContent = score;
            return;
        }

        if (Math.random() < 0.02) createObstacle();
        requestAnimationFrame(updateGame);
    }

    // Reuse existing functions like moveBoat, updateObstacles, checkCollision, drawScore
    // Ensure these functions are updated if necessary to handle new obstacle types
    function moveBoat(dx, dy) {
        boat.x += dx * boat.speed;
        boat.y += dy * boat.speed * 0.5; // Make vertical movement harder

        // Keep the boat within canvas bounds
        boat.x = Math.max(0, Math.min(canvas.width - boat.width, boat.x));
        boat.y = Math.max(0, Math.min(canvas.height - boat.height, boat.y));
    }

    function updateObstacles() {
        obstacles.forEach(obstacle => {
            obstacle.y += obstacle.speed;
        });

        obstacles = obstacles.filter(obstacle => obstacle.y < canvas.height);
    }

    function checkCollision() {
        return obstacles.some(obstacle =>
            boat.x < obstacle.x + obstacle.width &&
            boat.x + boat.width > obstacle.x &&
            boat.y < obstacle.y + obstacle.height &&
            boat.y + boat.height > obstacle.y
        );
    }

    function drawScore() {
        ctx.fillStyle = 'black';
        ctx.font = '20px Arial';
        ctx.fillText(`Score: ${score}`, 10, 30);
    }

    document.addEventListener('keydown', moveBoat);
    restartButton.onclick = restartGame;

    function restartGame() {
        gameOver = false;
        obstacles = [];
        score = 0;
        gameOverScreen.style.display = 'none';
        updateGame();
    }

    // Start game
    updateGame();
</script>
</body>
</html>