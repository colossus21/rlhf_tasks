<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Road Rush</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
        }
        #restart {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div id="gameName">Road Rush</div>
        <div id="score">Score: 0</div>
    </div>
    <button id="restart">Restart</button>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    let scene, camera, renderer, player, road, obstacles = [], score = 0, speed = 0.05, gameOver = false;

    function init() {
        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Blue background

        // Camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.5, 5);

        // Renderer
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Road
        const roadGeometry = new THREE.PlaneGeometry(10, 1000);
        const roadMaterial = new THREE.MeshBasicMaterial({color: 0x696969, side: THREE.DoubleSide});
        road = new THREE.Mesh(roadGeometry, roadMaterial);
        road.rotation.x = -Math.PI / 2;
        scene.add(road);

        // Player
        const playerGeometry = new THREE.BoxGeometry(0.5, 1, 0.5);
        const playerMaterial = new THREE.MeshBasicMaterial({color: 0x00ff00});
        player = new THREE.Mesh(playerGeometry, playerMaterial);
        scene.add(player);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(10, 20, 5);
        scene.add(directionalLight);

        // Trees
        for(let i = 0; i < 20; i++) {
            createTree(-3 + Math.random() * 6, -i * 50);
        }

        // Obstacles
        spawnObstacles();

        // Event listeners
        document.addEventListener('keydown', onKeyDown, false);
        document.getElementById('restart').addEventListener('click', restartGame);

        animate();
    }

    function createTree(x, z) {
        const tree = new THREE.Group();
        const trunk = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1, 0.2), new THREE.MeshBasicMaterial({color: 0x8B4513}));
        const leaves = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.7, 0.7), new THREE.MeshBasicMaterial({color: 0x228B22}));
        leaves.position.y = 0.8;
        tree.add(trunk, leaves);
        tree.position.set(x, 0.5, z);
        scene.add(tree);
    }

    function spawnObstacles() {
        if(Math.random() > 0.95) {
            const obstacle = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshBasicMaterial({color: 0xff0000}));
            obstacle.position.x = (Math.random() - 0.5) * 8;
            obstacle.position.z = -500;
            scene.add(obstacle);
            obstacles.push(obstacle);
        }
    }

    function onKeyDown(event) {
        if(gameOver) return;
        switch(event.keyCode) {
            case 37: // left
                player.position.x -= 0.5;
                break;
            case 39: // right
                player.position.x += 0.5;
                break;
            case 38: // up for jump animation
                if(player.position.y === 0.5) {
                    player.position.y = 1.5;
                    setTimeout(() => { if(!gameOver) player.position.y = 0.5; }, 500);
                }
                break;
        }
    }

    function animate() {
        requestAnimationFrame(animate);

        if(!gameOver) {
            // Move road and obstacles
            road.position.z += speed;
            obstacles.forEach(obstacle => {
                obstacle.position.z += speed;
                if(obstacle.position.z > camera.position.z) {
                    scene.remove(obstacle);
                    obstacles.splice(obstacles.indexOf(obstacle), 1);
                } else if(obstacle.position.distanceTo(player.position) < 0.5) {
                    gameOver = true;
                    document.getElementById('restart').style.display = 'block';
                }
            });

            // Score
            score += speed;
            document.getElementById('score').innerText = `Score: ${Math.floor(score)}`;

            // Increase speed
            speed += 0.0001;

            spawnObstacles();
        }

        renderer.render(scene, camera);
    }

    function restartGame() {
        scene.remove(player);
        obstacles.forEach(obstacle => scene.remove(obstacle));
        obstacles = [];
        score = 0;
        speed = 0.05;
        gameOver = false;
        document.getElementById('restart').style.display = 'none';
        init(); // Reinitialize game elements
    }

    init();
    </script>
</body>
</html>