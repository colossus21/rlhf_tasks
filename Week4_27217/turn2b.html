<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phaser Grid-Based Game</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #2d2d2d;
        }
        #gameContainer {
            width: 100%;
            height: 100%;
        }
        #modeText {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 20px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
</head>
<body>
<div id="gameContainer"></div>
<div id="modeText">Build Mode</div>
<script>
    const config = {
        type: Phaser.AUTO,
        width: window.innerWidth,
        height: window.innerHeight,
        parent: 'gameContainer',
        scene: {
            preload: preload,
            create: create,
            update: update
        },
        physics: {
            default: 'arcade',
            arcade: {
                debug: false
            }
        }
    };

    const game = new Phaser.Game(config);
    let player;
    let cursors;
    let mode = 'build'; // 'build' or 'destroy'
    let blocks;
    const gridSize = 32;

    function preload() {
        // No assets needed for this example
    }

    function create() {
        player = this.physics.add.sprite(0, 0, 'player').setOrigin(0, 0);
        player.setCollideWorldBounds(true);

        // Create invisible grid
        for (let y = 0; y < this.game.config.height; y += gridSize) {
            for (let x = 0; x < this.game.config.width; x += gridSize) {
                this.add.rectangle(x, y, gridSize, gridSize, 0xFFFFFF, 0).setOrigin(0, 0);
            }
        }

        blocks = this.physics.add.staticGroup();

        cursors = this.input.keyboard.createCursorKeys();
        this.input.keyboard.addKey('U').on('down', () => switchMode('build'), this);
        this.input.keyboard.addKey('O').on('down', () => switchMode('destroy'), this);

        // Block placement/removal keys
        this.input.keyboard.addKeys('W,A,S,D').W.on('down', () => placeOrRemoveBlock(0, -1));
        this.input.keyboard.addKeys('W,A,S,D').A.on('down', () => placeOrRemoveBlock(-1, 0));
        this.input.keyboard.addKeys('W,A,S,D').S.on('down', () => placeOrRemoveBlock(0, 1));
        this.input.keyboard.addKeys('W,A,S,D').D.on('down', () => placeOrRemoveBlock(1, 0));
    }

    function update() {
        // Player movement
        player.setVelocity(0);
        if (cursors.left.isDown) {
            player.x = Math.max(0, player.x - gridSize);
        } else if (cursors.right.isDown) {
            player.x = Math.min(this.game.config.width - gridSize, player.x + gridSize);
        }
        if (cursors.up.isDown) {
            player.y = Math.max(0, player.y - gridSize);
        } else if (cursors.down.isDown) {
            player.y = Math.min(this.game.config.height - gridSize, player.y + gridSize);
        }
    }

    function switchMode(newMode) {
        mode = newMode;
        document.getElementById('modeText').textContent = mode === 'build' ? 'Build Mode' : 'Destroy Mode';
    }

    function placeOrRemoveBlock(xOffset, yOffset) {
        const x = player.x + xOffset * gridSize;
        const y = player.y + yOffset * gridSize;
        const blockAtPosition = blocks.getChildren().find(block => block.x === x && block.y === y);

        if (mode === 'build' && !blockAtPosition) {
            const block = this.add.rectangle(x, y, gridSize, gridSize, 0xffff00).setOrigin(0, 0);
            this.physics.add.existing(block, true);
            blocks.add(block);
        } else if (mode === 'destroy' && blockAtPosition) {
            blockAtPosition.destroy();
        }
    }
</script>
</body>
</html>